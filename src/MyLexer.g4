lexer grammar MyLexer;

Accesslevel : PUBLIC | PRIVATE | PROTECTED;
PUBLIC : 'public';
PRIVATE : 'private';
PROTECTED : 'protected';

COMMENT :'/*' .*? '*/'->skip;
LINECOMMENT :  '#' ~( '\r' | '\n' )*->skip;
IMPORT : 'import';
IMPORTSTAR : 'import *';
FROM : 'from';
FLASH : '=>';
DOT : '.';
COMMA :  ',';
CLASS : 'class';
EXTEND : 'extends';
IMPLEMENT :'implements';
EQUAL :  '=';
WITH : 'with';
VAR : 'var';
CONST : 'const';
COLON : ':';
NEW : 'new';
ARRAY : 'Array';
BRACKETIN :  '[';
BRACKETOUT : ']';
RETURN : 'return';
IF : 'if';
ELIF : 'elif';
ELSE : 'else';
FOR : 'for';
IN : 'in';
TRY : 'try';
CATCH : 'catch';
ON : 'on';
WHILE : 'while';
DO : 'do';
SWITCH : 'switch';
CASE : 'case';
BREAK : 'break';
DEFAULT : 'default';
VOID : 'void';
PRINT : 'print';
DQUOTE: '"' -> pushMode(STRING);
PLUSEQUAL: '+=';
MINUSEQUAL : '-=';
MULTIEQUAL : '*=';
DIVIDEEQUAL1 : '/=';
DIVIDEEQUAL2 : '//=';
MODEQUAL : '%=';
NOT : 'not';
AND : 'and' | '&&';
OR : 'or' | '||';
LESS : '<';
GREATER : '>';
LESSEQUAL: '<=';
GREATEREQUAL : '>=';
EQUALITY : '==';
NOTEQUALITY: '!='| '<>';
BIT1 : '&';
BIT2: '|';
BIT3 : '^';
LESSLESS:'<<';
GREATERGREATER: '>>';
PLUS : '+';
MINUS : '-';
MULIT : '*';
DIVIDE1 : '/';
DIVIDE2 : '//';
MOD : '%';
PLUSPLUS : '++';
MINUSMINUS : '--';
TILDE: '~';
POW : '**';
DOLLAR : '$';
UNDERLINE : '_';
BOOL : TRUE | FALSE;
TRUE : 'true';
FALSE : 'false';
DOUBLE : INT* DOT INT+;
SCI : DIGIT DOT INT 'e' ('+' | '-') INT;
INT : DIGIT+;
fragment DIGIT : [0-9];
fragment LETTER : [A-Za-z];
BRACIN : '(';
BRACOUT : ')';
SEMI : ';' ;
BRACEIN : '{';
BRACEOUT : '}';
DATATYPE : 'Int' | 'String' | 'Double' | 'Bool';
WS : [ \t\r\n]+ -> skip;
NAME : (LETTER | DOLLAR | UNDERLINE) (LETTER | DOLLAR | UNDERLINE | DIGIT)+;

mode STRING;
STRINGTYPE: ('\\' ["\\] | ~["\\\r\n$])+ ;
STARTInterpolation: '${' -> pushMode(INTERPOLATION);
ESCAPEDOLLAR: '$' . ;
DQUOTE_IN_STRING: '"' -> type(DQUOTE), popMode;

mode INTERPOLATION;
S_NAME: (LETTER | DOLLAR | UNDERLINE) (LETTER | DOLLAR | UNDERLINE | DIGIT)+ -> type(NAME);
S_DQUOTE: '"' -> pushMode(STRING), type(DQUOTE);
S_SKIP : ' ' -> skip;
S_PLUS: '+' -> type(PLUS);
S_LESS : '<' ->type(LESS);
S_GREATER : '>' -> type(GREATER);
S_LESSEQUAL: '<=' -> type(LESSEQUAL);
S_GREATEREQUAL : '>=' -> type(GREATEREQUAL);
S_EQUALITY : '==' -> type(EQUALITY);
S_NOTEQUALITY: ('!=' | '<>') ->type(NOTEQUALITY);
S_MINUS : '-' ->type(MINUS);
S_MULIT : '*' ->type(MULIT);
S_DIVIDE1 : '/' ->type(DIVIDE1);
S_DIVIDE2 : '//' ->type(DIVIDE2);
S_MOD : '%' ->type(MOD);
S_PLUSPLUS : '++' ->type(PLUSPLUS);
S_MINUSMINUS : '--' ->type(MINUSMINUS);
S_TILDE: '~' ->type(TILDE);
S_POW : '**' ->type(POW);
S_BRACEIN: '{' -> type(BRACEIN), pushMode(INTERPOLATION);
S_BRACEOUT: '}' -> type(BRACEOUT), popMode;